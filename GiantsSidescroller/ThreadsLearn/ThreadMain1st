  package ThreadsLearn;

  import static ThreadsLearn.ThreadColor.*;

  /*
    When one preocess runs it gets its own memory space to run
    When one application is running and we run another application then both will have their own memory space of heap

    Note= the first application cannot access the heap that belongs to another java application.

    The thread is a unit of execution within a process. Each process can have multiple threads. In java each process has atleast one thread

    Note  = Creating thread does not require as many resources but every thread created by a process shaares the process's memory and files. this can
    create a problem in future.

    Every process has a heap and every thread has a thread stack

    The reason we use thread is
    1 As main program runs in a linear fashion which might still be waiting for the info from another computer
    but we still want the other processes to keep on running so we can run them in a different thread.
     */
public class ThreadMain1st {
    public static void main(String[] args) {
        System.out.println(ANSI_PURPLE +"Hello from the main thread");
        Thread anotherThread = new AnotheThread();// we need to invoke the run method
        anotherThread.start();// but to run the run method we do not use run method we wrtie thread.start() to ask JVM to invoke run

        // this is the way to create a annonymous class
        new Thread(() -> System.out.println(ANSI_GREEN+"Hello from the anonymous class thread")).start();

        Thread myRunnableThread = new Thread(new MyRunnable(){
            @Override
            public void run() {
                System.out.println(ANSI_RED+" Hello form the anonymous class's implmentation of runnable");
                try {
                    // so think here we asked another thread to join allowing another thread to finish its task and then let myrunnable thread to continue
                    anotherThread.join();// Note can end prematurely if it is interrupted by another thread// so we are waiting anotherThread to finish first and then my runnable will start implmenting
                System.out.println(ANSI_RED+" ANotherThread terminated, so i am running again");
                } catch (InterruptedException e) {
                    System.out.println("I could not wait after all. I was interrupted");
                }
            }
        });// this runs the myRunnable class on the another class
        myRunnableThread.start();

        //anotherThread.interrupt();// we interrupted the anotherThread before three seconds passed

        System.out.println(ANSI_PURPLE+"Hello again from the main thread");
        /*
        after running this we realized that line 33 got excuted first but line 28 got executed later. so it depends how much time that
        thread takes to finish the process and when will the scheduler schedule the execution of that thread.
         */

        //anotherThread.start();// We cannot do that run method only run ones for that particular thread we need to create new one for it run
    }
}
